<!doctype html><html lang="ru"></html><head><link rel="icon" href="favicon.ico"><link href="styles.c7c243772ad14777a948.css" rel="stylesheet"></head><meta charset="UTF-8"><title>Typescript</title><body><div class="preloader" id="preloader"><div class="preloader__loader"><div class="wrap-prelodaer-img"><div class="preloader-img"><div></div></div></div></div></div><div class="wrapper hide" id="wrapper"><header class="header scrollto" id="header"><div class="header__container flex"><button class="header__burger header-burger btn flex" id="burger"><span class="header-burger__line"></span></button><a class="header__logo header-logo link" href="#">S</a><nav class="header__nav"><ul class="header__menu header-menu list flex"><li class="header-menu__item"><a class="header-menu__link link" href="./index.html"><span class="header-menu__link-text">Node.js и NPM</span></a></li><li class="header-menu__item"><a class="header-menu__link link" href="./typescript.html"><span class="header-menu__link-text">TypeScript</span></a></li><li class="header-menu__item"><a class="header-menu__link link" href="./testing.html"><span class="header-menu__link-text">Тестирование</span></a></li></ul></nav></div></header><main class="main" id="main"><section class="hero" id="hero"><div class="hero__container"><h1 class="hero__title">TypeScript</h1><p class="hero__text"><strong>TypeScript</strong> &mdash;&nbsp;предоставляет статическую типизацию, что означает, что вы&nbsp;можете задавать типы переменных, параметров функций и&nbsp;возвращаемых значений.</p><p class="hero__text">Основная цель <strong>TypeScript</strong>&nbsp;&mdash; сделать разработку более предсказуемой и&nbsp;удобной, особенно в&nbsp;больших проектах.</p><nav class="hero__nav"><ul class="hero__menu hero-menu list flex"><li class="hero-menu__item"><a class="hero-menu__link link active" href="#tsc"><span class="hero-menu__link-text">Установка TypeScript</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#linters"><span class="hero-menu__link-text">Линтеры</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#gts"><span class="hero-menu__link-text">Google TypeScript Style (gts)</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#vite"><span class="hero-menu__link-text">Vite</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#webpack"><span class="hero-menu__link-text">Webpack</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#typing"><span class="hero-menu__link-text">Основы типизации</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#nickname"><span class="hero-menu__link-text">Псевдонимы</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#object"><span class="hero-menu__link-text">Типизация объектов</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#function"><span class="hero-menu__link-text">Типизация функций</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#special"><span class="hero-menu__link-text">Специальные (утилитарные) типы</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#modules"><span class="hero-menu__link-text">TypeScript и модули</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#oop"><span class="hero-menu__link-text">ООП</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#modifiers"><span class="hero-menu__link-text">Модификаторы доступа и static</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#interface"><span class="hero-menu__link-text">Интерфейс в TypeScript</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#union"><span class="hero-menu__link-text">Объединение и пересечение</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#tuple"><span class="hero-menu__link-text">Динамические объекты и кортежи</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#generics"><span class="hero-menu__link-text">Дженерики</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#optional"><span class="hero-menu__link-text">Функции: опциональные параметры и перегрузка</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#operators"><span class="hero-menu__link-text">typeof, import type и keyof - извлечение типов из значений</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#"><span class="hero-menu__link-text">link</span></a></li><li class="hero-menu__item"><a class="hero-menu__link link" href="#example"><span class="hero-menu__link-text">Пример</span></a></li></ul></nav></div></section><section class="tsc section-scroll" id="tsc"><div class="tsc__container"><h2 class="tsc__title">Установка TypeScript</h2><p class="tsc__text"><code class="tsc__code">mkdir <i>folder-template-tsc</i> - создание папки проекта</code></p><p class="tsc__text"><code class="tsc__code">cd <i>folder-template-tsc</i> - переход в папку проекта</code></p><p class="tsc__text"><code class="tsc__code">npm init - инициализация проекта, создание package.json</code></p><p class="tsc__text"><code class="tsc__code">npm install typescript --save-dev - установка TypeScript</code></p><p class="tsc__text"><code class="tsc__code">example.ts - создание файла с кодом</code></p><p class="tsc__text"><code class="tsc__code">npx tsc <i>example.ts</i> - компиляция в JS</code></p><p class="tsx__text">npm также включает инструмент под названием npx, который запускает исполняемые пакеты без необходимости устанавливать их&nbsp;глобально.</p><br><h3 class="tsc__heading">Иницилазиация проекта</h3><p class="tsc__text"><code class="tsc__code">npx tsc --init</code></p><p class="tsc__text">Инициализация проекта путём создания файла <strong>tsconfig.json</strong></p><br><p class="tsc__text">В <strong>tsconfig.json</strong> раскомменитровать:</p><pre class="pre">"outDir": "docs", <i>// указать папку, куда будет компилироваться файл</i>
"sourceMap": true</pre><br><h3 class="tsc__heading">Компиляция в JS</h3><p class="tsc__text"><code class="tsc__code">npx tsc index.ts</code></p><br><h3 class="tsc__heading">Запуск кода в ts-файле без компиляции в JS</h3><p class="tsc__text"><code class="tsc__code">npx tsx index.ts</code></p><br><h3 class="tsc__heading">Активация режима наблюдения для автоматической компиляции после внесения каждого изменения</h3><p class="tsx__text"><code class="tsc__code">npx tsc -w</code></p></div></section><section class="linters section-scroll" id="linters"><div class="linters__container"><h2 class="linters__title">Линтеры</h2><p class="linters__text"><strong>Линтеры</strong> (линтеры кода)&nbsp;&mdash; это инструменты, которые автоматически анализируют исходный код, чтобы находить ошибки, потенциальные баги, нарушения стандартов стиля, неоптимальные конструкции и&nbsp;несоответствия кодстайлам.</p><p class="linters__text">Использование линтера при написании кода поможет быстро выявить несоответствия, синтаксические ошибки и&nbsp;упущения.</p><div class="linters__wrap"><h3 class="linters__heading">ESLint</h3><p class="linters__text">Источники:</p><p class="linters__text"><a class="linters__link" href="https://github.com/palantir/tslint#tslint" target="_blank">https://github.com/palantir/tslint#tslint</a></p><p class="linters__text"><a class="linters__link" href="https://typescript-eslint.io/" target="_blank">https://typescript-eslint.io/</a></p><ol class="linters__list linters-list"><li class="linters-list__item"><h4 class="linters-list__headline">Установка ESLint:</h4><code class="linters-list__text">npm install --save-dev eslint</code></li><li class="linters-list__item"><h4 class="linters-list__headline">Инициализируй конфиг ESLint (рекомендуется):</h4><code class="linters-list__text">npx eslint --init</code><p class="linters-list__text">Настройка:</p><ul class="linters-list__settings linters-settings"><li class="linters-settings__item"><p class="linters-settings__text">Тип проекта (JavaScript/TypeScript)</p></li><li class="linters-settings__item"><p class="linters-settings__text">Фреймворки (React, Vue, None)</p></li><li class="linters-settings__item"><p class="linters-settings__text">Формат конфига (JSON, YAML, JS и др.)</p></li><li class="linters-settings__item"><p class="linters-settings__text">Применять ли сразу исправления</p></li></ul></li><li class="linters-list__item"><h4 class="linters-list__headline">Плагин для TypeScript:</h4><code class="linters-list__text">npm install --save-dev @typescript-eslint/parser @typescript-eslint/eslint-plugin</code></li><li class="linters-list__item"><h4 class="linters-list__headline">Добавление/доработка конфиг '.eslintrc.js' или '.eslintrc.json':</h4><p class="linters-list__text">Пример минимального `.eslintrc.js` для TypeScript:</p><pre class="pre">module.exports = {
  parser: '@typescript-eslint/parser',
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
  ],
  plugins: [
    '@typescript-eslint',
  ],
  rules: {
    <i>// здесь можно добавить свои правила</i>
  },
};</pre></li><li class="linters-list__item"><h4 class="linters-list__headline">Проверка кода:</h4><code class="linters-list__text">npx eslint . --ext .js,.jsx,.ts,.tsx</code></li></ol></div></div></section><section class="gts section-scroll" id="gts"><div class="gts__container"><h2 class="gts__title">Google TypeScript Style (gts)</h2><p class="gts__text"><strong>Google TypeScript Style (gts)</strong>&nbsp;&mdash; это набор стандартов оформления (code style) кода на&nbsp;TypeScript, разработанный Google.</p><p class="gts__text">Сам <strong>gts</strong> (npm-пакет с&nbsp;таким названием)&nbsp;&mdash; это инструмент, который внедряет и&nbsp;автоматически поддерживает эти стандарты в&nbsp;вашем проекте.</p><p class="gts__text">Ссылки:</p><p class="gts__text"><a href="https://github.com/google/gts" target="_blank">готовая сборка ESLint-правил</a></p><p class="gts__text"><a href="https://npmjs.com/package/gts" target="_blank">npm-пакет</a></p><ol class="gts__list gts-list"><li class="gts-list__item"><h3 class="gts-list__title">Установка:</h3><pre class="pre">npm install --save-dev gts
npx gts init</pre></li><li class="gts-list__item"><h3 class="gts-list__title">Настройка:</h3><p class="gts-list__text">Добавляет в&nbsp;проект конфиги ESLint, Prettier, делает типовой tsconfig, скрипты, правила gitignore и&nbsp;editorconfig.</p></li><li class="gts-list__item"><h3 class="gts-list__title">Проверка и исправление:</h3><pre class="pre">npm run lint
npm run fix</pre></li><li class="gts-list__item"><h3 class="gts-list__title">Интеграция с ESLint:</h3></li></ol></div></section><section class="vite section-scroll" id="vite"><div class="vite__container"><h2 class="vite__title">Vite</h2><ol class="vite__list vite-list"><li class="vite-list__item"><code class="vite-list__code">npm create vite@latest <i>vite-ts-project</i> -- --template vanilla-ts - vite-ts-project (название проекта)</code></li><li class="vite-list__item"><code class="vite-list__code">npm init - инициализация проекта, создание package.json</code></li><li class="vite-list__item"><code class="vite-list__code">npm install - установка зависимостей</code></li><li class="vite-list__item"><code class="vite-list__code">npm run dev - запуск dev-сервера</code></li></ol></div></section><section class="webpack section-scroll" id="webpack"><div class="webpack__container"><h2 class="webpack__title">Webpack</h2><ol class="webpack__list webpack-list"><li class="webpack-list__item"><code class="webpack-list__code">mkdir <i>webpack-ts</i> - создание папки проекта</code></li><li class="webpack-list__item"><code class="webpack-list__code">npm init -y - инициализация проекта, создание package.json</code></li><li class="webpack-list__item"><code class="webpack-list__code">touch <i>webpack.config.js</i> - создание webpack.config.js</code><pre class="webpack__pre pre">const path = require('path');

module.exports = {
  mode: 'development', <i>// или 'production' для сборки в продакшн</i>
  entry: './src/index.ts', <i>// точка входа</i>
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js' <i>// имя выходного файла</i>
  },
  resolve: {
    extensions: ['.tsx', .ts', '.js'] <i>// расширения</i>
  },
  module: {
    rules: [
      {
        test: /\.tsx$/, <i>// Регулярное выражение для файлов .ts и .tsx</i>
        use: 'ts-loader', <i>// Использование ts-loader</i>
        exclude: /node_modules/, <i>// Игнорирование папки node_modules</i>
      }
    ]
  }
}</pre></li><li class="webpack-list__item"><p class="webpack-list__text">создать файл <b>index.ts</b></p></li><li class="webpack-list__item"><code class="webpack-list__code">npm install webpack webpack-cli --save-dev - установка webpack</code></li><li class="webpack-list__item"><p class="webpack-list__text">В <b>package.json</b> прописать команды:</p><code class="webpack-list__code">"scripts": { "build": "webpack }</code></li><li class="webpack-list__item"><p class="webpack-list__text">Создание файла <b>tsconfig.json</b></p><code class="webpack-list__code">touch <i>tsconfig.json</i>:</code><pre class="webpack-list__pre pre">{
  "compilerOptions": {
    "target": "es6", <i>// целевая версия JavaScript</i>
    "module": "commonjs", <i>// модульная система</i>
    "outDir": "dist", <i>// директория для выходных файлов</i>
    "strict": true, <i>// включение строгого режима</i>
    "esModuleInterop": true <i>// включение совместимости с ES6 модулями</i>
    "skipLibCheck": true, <i>// пропуск проверки типов в файлах определения</i>
    <i>// strictNullChecks: true</i> - проверка методов на null
    <i>// strictFunctionTypes: true</i> - проверка типов параметров функций, переданные в аргументы
    <i>// strictBindCallApply: true</i> - ужесточение правил для методов bind, call, apply
    <i>// strictPropertyInitialization: true</i> - требует, чтобы все типы свойств классов были предопределены
  },
  "include": {
    "src/**/*" <i>// включение всех файлов в директории src</i>
  }
}</pre></li><li class="webpack-list__item"><code class="webpack-list__code">npx tsc <i>index.ts</i> - компиляция в JS</code></li><li class="webpack-list__item"><code class="webpack-list__code">npm run build - запуск команды</code></li></ol></div></section><section class="typing section-scroll" id="typing"><div class="typing__container"><h2 class="typing__title">Основы типизации</h2><ul class="typing__list typing-list list"><li class="typing-list__item"><pre class="pre">const isTrue: boolean = true;
const something: undefined = undefined;
const add = (a: number, b: number): number =&gt; a + b;
const arrayString: string[] = ["forst", "secont", "try"];
const arrayBoolean: boolean[] = [true, false, true];
const arrayOfArrBoolean: boolean[][] = [[true, false, true], [true, false, true], [true, false, true]];</pre></li><li class="typing-list__item"><pre class="pre">class Person {
  name: string;
  age?: number;
  constructor(name: string, age?: number) {
    this.name = name;
    this.age = age;
  }
}

const woman = new Person("Elizabeth");
console.log(woman); <i>// { name: "Elizabeth", age: undefined }</i></pre></li><li class="typing-list__item"><pre class="pre">function smth(a: string|number) {
  if (typeof a === "number") {
    return a*a
  }
  if (typeof a === "string") {
    return `input ${a}`
  }
}

console.log('number:' smth(5));
console.log("string:" smth('dream'));</pre></li><li class="typing-list__item"><pre class="pre"><i>// Литеральные типы - представляют собой способ указания конкретных значений, которые могут принимать переменные</i>
let trafficLight: 'red' | "green" | "yellow" | "error" = "green";
trafficLight = "yellow";
trafficLight = "orange"; <i>// выдаст ошибку</i>
trafficLight = "error";</pre></li><li class="typing-list__item"><pre class="pre"><i>// enum (перечисление) - создание набора именованных констант</i>
enum Direction {
  Up = "up", <i>// если не присвоить значение, то будет 0</i>
  Down = "down", <i>// если не присвоить значение, то будет 1</i>
  Left = "left", <i>// если не присвоить значение, то будет 2</i>
  Right = "right" <i>// если не присвоить значение, то будет 3</i>
}

let playerDirection: Direction;
playerDirection = Direction.Up;
if (playerDirection === Direction.Up) {
  console.log(`Player is moving ${playerDirection}`); <i>// Player is moving up</i>
}</pre></li></ul></div></section><section class="nickname section-scroll" id="nickname"><div class="nickname__container"><h2 class="nickname__title">Псевдонимы</h2><p class="nickname__text">В&nbsp;TypeScript псевдоним типа (type alias)&nbsp;&mdash; это способ дать новому имени существующему типу или комбинации типов.</p><p class="nickname__text">Для обозначения <strong>псевдонима</strong> используется ключевое слово <strong>type</strong>.</p><ol class="nickname__list nickname-list list"><li class="nickname-list__item"><h3 class="nickname-list__title">Простой тип</h3><pre class="pre">type UserName = string;

const name: UserName = 'Анна';</pre></li><br><li class="nickname-list__item"><h3 class="nickname-list__title">Объектный тип</h3><pre class="pre">type User = {
  name: string;
  age: number;
};

const user: User = {
  name: 'Игорь',
  age: 30
};</pre></li><br><li class="nickname-list__item"><h3 class="nickname-list__title">Объединение типов (Union type)</h3><pre class="pre">type Status = 'success' | 'error' | 'loading';

let state: Status = 'success';
state = 'error'; <i>// ✅</i>
state = 'idle'; <i>// ❌ Ошибка: 'idle' не входит в type Status</i></pre></li><br><li class="nickname-list__item"><h3 class="nickname-list__title">Массив с псевдонимами</h3><pre class="pre">type Point = {
  x: number;
  y: number;
};

type Points = Point[]; <i>// массив точек</i>

const coords: Points = [{ x: 10, y: 20 }, { x: 0, y: 0 }];</pre><br></li><li class="nickname-list__item"><h3 class="nickname-list__title">Функциональный тип</h3><pre class="pre">type MathOperation = (a: number, b: number) =&gt; number;

const add: MathOperation = (a, b) =&gt; a + b;
const sub: MathOperation = (a, b) =&gt; a - b;</pre></li></ol></div></section><section class="object section-scroll" id="object"><div class="object__container"><h2 class="object__title">Типизация объектов</h2><pre class="pre">type ApiResponse = {
  id: number, name: string
}

const response: ApiResponse = fetchDataFromAPI();</pre><pre class="pre">type User = {
  name: string,
  age: number,
  greet: () =&gt; void
}

const user: User = {
  name: "John",
  age: 30,
  greet() {
    console.log(`Hello! My name is ${this.name} and i'm ${this.age} years old.`);
  }
}

console.log(user.greet());</pre></div></section><section class="function section-scroll" id="function"><div class="function__container"><h2 class="function__title">Типизация функций</h2><pre class="pre">type Callback = {
  (arg: string): number
}

function higherOrderFunction(callback: Callback): void {
  <i>// Реализация функции</i>
}</pre></div></section><section class="special section-scroll" id="special"><div class="special__container"><h2 class="special__title">Специальные типы</h2><p class="special__text"><strong>any</strong>&mdash;&nbsp;любой тип и&nbsp;TypeScript не&nbsp;будет проверять его типовую совместимость во&nbsp;время компиляции.</p><pre class="pre"><i>// let value = 10 as any;</i>
let value: any = 10;
console.log(value); <i>// 10</i>

value = "Hello";
console.log(value); <i>// Hello</i>

value = true;
console.log(value); <i>// true</i></pre><br><p class="special__text"><strong>unknown</strong>&nbsp;&mdash; когда тип переменной неизвестен и&nbsp;требует явного указания типа.</p><pre class="pre">let value: unknown;
value = 42;

if (typeof value === "number") {
  let num: number = value; <i>// безопасно</i>
}</pre><br><p class="special__text"></p><strong>never</strong>&nbsp;&mdash; когда функция никогда не&nbsp;возвращает значение или возникает ошибка.<pre class="pre">function throwError(message: string): never {
  throw new Error(message);
}</pre><br><p class="special__text"><strong>void</strong>&nbsp;&mdash; указывает, что функция не&nbsp;возвращает никакого значения.</p><pre class="pre">const btn = document.getElementById("btn");

<i>// addEventListener принадлежит к типу void</i>
btn.addEventListener("click", () =&gt; {
  console.log("Button clicked");
});

<i>// или</i>

function log(message: string): void {
  console.log(message);
}</pre><br><p class="special__text"></p><strong><a href="#tuples">Кортежи (tuples)</a></strong> позволяют создать массив фиксированной длины с&nbsp;элементами различных типов.<pre class="pre">let tuple: [string, number];
tuple = ["John", 30]; <i>// допустимо</i></pre><br><p class="special__text" id="record"><strong>Record</strong>&nbsp;&mdash; тип-объект, который позволяет создавать объекты с&nbsp;определенным набором ключей и&nbsp;их&nbsp;соответствующими типами значений.</p><p class="special__text"><strong>Record</strong> использует дженерики.</p><pre class="pre">type Person = Record&lt;string, string | number&gt;; <i>// ключ - значение</i>
const person: Person = {
  name: "John",
  age: 30
};

<i>/* ==================================================================================================== */</i>

type UserRoles = 'admin' | 'user' | 'guest';

type UserPermissions = Record&lt;UserRoles, string[]&gt;;
type UserPermissions1 = Record&lt;string, string[]&gt;;

const permissions: UserPermissions = {
  admin: ['read', 'write', 'delete'],
  user: ['read', 'write'],
  guest: ['read'],
  gamer: ['read', 'write', 'play'] <i>// Error - нет такого ключа</i>
}</pre><br><h3 class="special__heading">Утилитарные типы</h3><p class="special__text"><strong>Partial</strong>&nbsp;&mdash; утилитный тип, который позволяет создать новый тип, где все свойства оригинального типа становятся необязательными.</p><p class="special__text">Делает всё свойства объекта опциональными.</p><pre class="pre">interface User {
  id: number;
  name: string;
}

type PartialUser = Partial&lt;User&gt;;</pre><br><p class="special__text"><strong>Required</strong>&nbsp;&mdash; противоположный `Partial`. Создает новый тип, где все свойства оригинального типа обязательны.</p><p class="special__text">Делает все свойства объекта обязательными.</p><pre class="pre">type RequiredUser = Required&lt;PartialUser&gt;;</pre><br><p class="special__text"><strong>Pick</strong> и&nbsp;<strong>Omit</strong>&nbsp;&mdash; эти утилиты позволяют создавать новые типы путем выбора или исключения определенных свойств из&nbsp;существующего типа.</p><p class="special__text"><strong>Pick</strong> выбирает указанные свойства из объекта.</p><p class="special__text"><strong>Omit</strong> исключает указанные свойства из объекта.</p><pre class="pre"><i>// Вариант №1</i>            
type PickUser = Pick&lt;User, 'id'&gt;; <i>// выбирает id</i>
type OmitUser = Omit&lt;User, 'name'&gt;; <i>// исключает name</i>

<i>// Вариант №2</i>
interface User {
  name: string;
  age: number;
  email?: string;
}

<i>// Pick</i>
type PickUser = Pick&lt;User, 'name' | 'email'&gt;; <i>// { name: string; email?: string }</i>

<i>// Omit</i>
type OmitUser = Omit&lt;User, 'age'&gt;; <i>// { name: string; email?: string }</i></pre><br><p class="special__text" id="readonly">Оператор <b>readonly</b> делает свойства объектов, массивов или других структур данных доступными только для чтения (immutable).</p><p class="special__text">Делает все свойства объекта неизменяемыми.</p><pre class="pre">interface User {
  readonly id: number;
  name: string;
}

const user: User = { id: 1, name: "Alex" };

user.name = "John"; <i>// ✅ Разрешено</i>
user.id = 2; <i>// ❌ Ошибка: нельзя изменять readonly свойство</i></pre><br><h3 class="special__heading" id="utilitarian">Утилитарные типы в пересечениях.</h3><p class="special__text"><strong>Extract</strong> выделяет общие элементы двух объединений типов.</p><p class="special__text"><strong>Exclude</strong> исключает элементы одного типа из элементов другого.</p><pre class="pre"><i>// Extract&lt;T, U&gt; - создаёт тип, который включает только те члены типа T, которые есть в типе U</i>
type Extracted = Extract&lt;'a' | 'b' | 'c', 'b' | 'c' | 'd'&gt;; <i>// 'b' | 'c'</i>
<i>// b и с - остаются, т.к., они есть в T и U</i>
<i>// 'a' - исключает, т.к., нет в типе U</i>
<i>// 'c' - исключает, т.к., нет в типе T</i>

<i>// Одинаковый результат</i>
type X1 = Extract&lt;'a' | 'b', 'b' | 'c'&gt;; <i>// 'b'</i>

type X2 = ('a' | 'b') &amp; ('b' | 'c'); <i>// 'b'</i>
<i>// используется пересечение |</i>
<i>// а затем применяется оператор &amp;</i>
<i>// оператор &amp; удаляет неповторяющиеся значения.</i>
<i>// т.е.:</i>
<i>// Со строковыми литералами TypeScript строг!</i>
<i>// Тип пересечения строковых литералов типа `&rsquo;a&rsquo; &amp; &rsquo;b&rsquo;` не&nbsp;имеет смысла, это разные строки, и&nbsp;один не&nbsp;может быть одновременно и &rsquo;a&rsquo;, и &rsquo;b&rsquo;.</i>
<i>// Поэтому TypeScript упрощает такое пересечение до&nbsp;never, если нет пересечения во&nbsp;множестве значений.</i>



<i>// Exclude&lt;T, U&gt; - создаёт тип, который исключает те члены из типа T, которые есть в типе U</i>
type Color = "red" | "green" | "blue";
type PrimaryColor = Exclude&lt;Color, "green"&gt;; <i>// "red" | "blue"</i>

type Mixed = string | number | boolean;
type OnlyNumbers = Exclude&lt;Mixed, string | boolean&gt;; <i>// number</i>

type Excluded = Exclude&lt;'a' | 'b' | 'c', 'b' | 'c' | 'd'&gt;; <i>// 'a'</i>
<i>// 'a' есть в T, но нет в U - остаётся</i>
<i>// 'b' есть в T и U - удаляется</i>
<i>// 'c' есть в T и U - удаляется</i>
<i>// 'd' удаляется, т.к., нет в T</i></pre><pre class="pre"><i>// Под капотом (как работает)</i>
<i>// Extract</i>
type MyExtract&lt;T, U&gt; = T extends U ? T : never;

<i>// Exclude</i>
type MyExclude&lt;T, U&gt; = T extends U ? never : T;</pre><br><h3 class="special__heading" id="borrowing">Работа с функциями</h3><p class="special__text">Утилитарные типы помогают при работе с&nbsp;функциями и&nbsp;классами.</p><p class="special__text">Мы&nbsp;можем получить кортеж из&nbsp;типов параметров функции или тип возвращаемого функцией значения (чтобы передать тип функции, нужно использовать typeof).</p><ul class="special__list special-list"><li class="special-list"><p class="special__text"><strong>ReturnType</strong> извлекает тип возвращаемого значения функции.</p></li><li class="special-list"><p class="special__text"><strong>Parameters</strong> извлекает типы параметров функции в виде кортежа.</p></li><li class="special-list"><p class="special__text"><strong>ConstructorParameters</strong> извлекает типы параметров конструктора класса в виде кортежа.</p></li></ul><pre class="pre">function exampleFunction(a: string, b: number): boolean {
  return a.length &gt; b;
}

type FuncReturnType = ReturnType&lt;typeof exampleFunction&gt;; <i>// boolean</i>

type FuncParameters = Parameters&lt;typeof exampleFunction&gt;; <i>// [string, number]</i>

class ExampleClass {
  constructor(x: string, y: number) {}
}

type ConstructorParams = ConstructorParameters&lt;typeof ExampleClass&gt;; <i>// [string, number]</i>


<i>// Получение параметра по индексу</i>
type FirstParam = Parameters&lt;typeof exampleFunction&gt;[0]; <i>// string</i>


<i>// Перегруженная функция</i>
function overLoaded(a: string): string;
function overLoaded(a: number): number;
function overLoaded(a: any): any {
  if (typeof a === "string") {
    return a.length;
  } else {
    return a.toString();
  }
};

type OverLoadedReturnType = ReturnType&lt;typeof overLoaded&gt;; <i>// string | number</i></pre><br><h3 class="special__heading">Работа со строкам</h3><ul class="special__list special-list"><li class="special-list__item"><p class="special-list__text"><strong>Uppercase</strong> делает все символы строки заглавными.</p></li><li class="special-list__item"><p class="special-list__text"><strong>Lowercase</strong> делает все символы строки строчными.</p></li><li class="special-list__item"><p class="special-list__text"><strong>Capitalize</strong> делает первый символ строки заглавным.</p></li><li class="special-list__item"><p class="special-list__text"><strong>Uncapitalize</strong> делает первый символ строки строчным.</p></li></ul><pre class="pre">type UppercaseString = Uppercase&lt;'hello'&gt;; <i>// 'HELLO'</i>

type LowercaseString = Lowercase&lt;'HELLO'&gt;; <i>// 'hello'</i>

type CapitalizedString = Capitalize&lt;'hello'&gt;; <i>// 'Hello'</i>

type UncapitalizedString = Uncapitalize&lt;'Hello'&gt;; <i>// 'hello'</i></pre></div></section><section class="modules section-scroll" id="modules"><div class="modules__container"><h2 class="modules__title">TypeScript и модули</h2><p class="modules__text">_types.ts:</p><pre class="pre">export type Person = {
  name: string;
  age: number;
}</pre><br><p class="modules__text">_utils.ts:</p><pre class="pre">export function greet(name: string): void {
  console.log(`Hello, ${name}!`);
}

const country: string = "USSR";
export { country };</pre><br><p class="modules__text">index.ts:</p><pre class="pre">import type { Person } from "./types";
import { greet, country } from "./utils";

const man: Person = {name: "John", age: 30};
greet("James");

console.log("man:", man);
console.log("country:", country);</pre><br><br><p class="modules__text"><code>npm i <i>lodash</i> --save-dev</code> &mdash;&nbsp;это JavaScript-библиотека, которая предоставляет множество функций для работы с&nbsp;массивами, объектами, строками и&nbsp;прочими типами данных.</p><p class="modules__text">Она существенно облегчает и ускоряет процесс разработки, особенно когда речь идет о манипуляциях с данными.</p></div></section><section class="oop section-scroll" id="oop"><div class="oop__container"><h2 class="oop__title">Объектно-ориентированное программирование</h2><p class="oop__text"><b>Объектно-ориентированное программирование (ООП)</b>&nbsp;&mdash; это методология разработки программного обеспечения, которая основана на&nbsp;концепции &laquo;объектов&raquo;.</p><p class="oop__text">Эти объекты могут представлять реальные вещи или абстрактные идеи и&nbsp;служат строительными блоками программного обеспечения.</p><p class="oop__text">ООП позволяет организовать код таким образом, чтобы он&nbsp;был более понятным, удобным для сопровождения и&nbsp;повторного использования.</p><hr><h3 class="oop__heading">Основные концепции ООП:</h3><ul class="oop__list oop-list"><li class="oop-list__item"><h3 class="oop-list__title">Классы и объекты</h3><p class="oop-list__text"><b>Класс</b>&nbsp;&mdash; это шаблон или структура, определяющая свойства и&nbsp;методы, которые имеют объекты. Класс представляет концепцию или категорию объектов.</p><p class="oop-list__text"><b>Объект</b>&nbsp;&mdash; это конкретный экземпляр класса. Он&nbsp;содержит данные в&nbsp;виде свойств и&nbsp;может выполнять действия, определенные методами класса.</p></li><li class="oop-list__item"><h3 class="oop-list__title">Инкапсуляция</h3><p class="oop-list__text">Это принцип, который подразумевает скрытие внутреннего состояния объекта и&nbsp;предоставление доступа к&nbsp;нему только через специальные методы (геттеры и&nbsp;сеттеры).</p><p class="oop-list__text">Это помогает защитить данные и&nbsp;контролировать, как они изменяются.</p><p class="oop-list__text">Простыми словами: <b>Инкапсуляция</b>&nbsp;&mdash; это упаковка данных и&nbsp;функций в&nbsp;один компонент и&nbsp;последующий контроль доступа к&nbsp;этом компоненту.</p></li><li class="oop-list__item"><h3 class="oop-list__title">Наследование</h3><p class="oop-list__text">Это механизм, позволяющий создавать новые классы на&nbsp;основе уже существующих.</p><p class="oop-list__text">Новый класс (наследник) может наследовать свойства и&nbsp;методы родительского класса (базового класса), а&nbsp;также добавлять свои собственные или переопределять унаследованные.</p></li><li class="oop-list__item"><h3 class="oop-list__title">Полиморфизм</h3><p class="oop-list__text">Это способность объектов различных классов обрабатывать сообщения одного и&nbsp;того&nbsp;же типа по-разному.</p><p class="oop-list__text">Полиморфизм позволяет использовать один интерфейс для разных типов данных, что делает код более гибким и&nbsp;расширяемым.</p></li></ul><hr><p class="oop__text"><b>Синтаксис типизированного класса и его экземпляра:</b></p><pre class="pre"><i>// Класс</i>
class Car {
  model: string;
  color: string;

  constructor(model: string, color: string) {
    this.model = model;
    this.color = color;
  }
}

<i>// Объект (экземпляр класса)</i>
const myCar = new Car('BMW', 'Black');</pre><p></p></div></section><section class="modifiers section-scroll" id="modifiers"><div class="modifiers__container"><h2 class="modifiers__title">Модификаторы доступа и static</h2><div class="modifiers__block"><h3 class="modifiers__heading">Public</h3><p class="modifiers__text">Модификатор <b>public</b> (по&nbsp;умолчанию) делает свойство или метод доступными отовсюду.</p><pre class="pre">class Car {
  public model: string;
  color: string;

  constructor(model: string, color: string) {
    this.model = model;
    this.color = color;
  }

  public greetModel() {
    console.log(`Hello! Model my car is ${this.model}`);
  }

  greetColor() {
    console.log(`Hello! Color my car is ${this.color}`);
  }
}

const myCar = new Car("Kalina", "Black");
myCar.greetModel; <i>// Hello! Model my car is Kalina</i>
myCar.greetColor; <i>// Hello! Color my car is Black</i></pre></div><br><br><div class="modifiers__block"><h3 class="modifiers__heading">Private</h3><p class="modifiers__text">Модификатор <b>private</b> ограничивает доступ к&nbsp;свойствам и&nbsp;методам только внутри самого класса. Т.е., они доступны только внутри класса.</p><pre class="pre">class Car {
  private model: string; <i>// Нельзя использовать в наследниках</i>
  color: string;

  constructor(model: string, color: string) {
    this.model = model;
    this.color = color;
  }

  private greetModel() {
    console.log(`Hello! Model my car is ${this.model}`);
  }

  greetColor() {
    console.log(`Hello! Color my car is ${this.color}`);
  }
}

const myCar = new Car("Kalina", "Black");

console.log(myCar.model); <i>// Ошибка: свойство 'model' недоступно</i>

myCar.greetModel; <i>// Ошибка: свойство 'greetModel' недоступно</i>

myCar.greetColor; <i>// Hello! Color my car is Black</i></pre></div><br><br><div class="modifiers__block"><h3 class="mo_heading">Protected</h3><p class="modifiers__text">Модификатор <b>protected</b> предоставляет доступ к&nbsp;свойствам и&nbsp;методам <b>внутри самого класса</b> и&nbsp;его <b>подклассам (наследникам)</b>.</p><p class="modifiers__text">Т.е., может использоваться внутри самого класса или извне через подклассы (наследники).</p><pre class="pre"><i>// Родительский класс</i>
class Car {
  protected model: string;
  color: string;

  constructor(model: string, color: string) {
    this.model = model;
    this.color = color;
  }
}

<i>// Подкласс (наследник)</i>
class MyCar extends Car {
  public speed: number;

  constructor(model: string, color: string, speed: number) {
    super(model, color);
    this.speed = speed;
  }

  greetMyCar() {
    console.log(`Hello! Model my car is ${this.model}. The maximum speed of my car is ${this.speed} km/h. Color my car is ${this.color}.`);
  }
}

const myCar = new MyCar("Kalina", "black", 160);
myCar.greetMyCar; <i>// Hello! Model my car is Kalina. The maximum speed of my car is 160 km/h. Color my car is black.</i></pre></div><br><br><table class="modifiers__table modifiers-table" border="1" cellspacing="0" cellpadding="3"><caption class="modifiers-table__title">Уровни доступа:</caption><thead><tr><th>Модификатор</th><th>Внутри класса</th><th>В подклассе</th><th>Вне класса</th></tr></thead><tbody><tr><td>public</td><td><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="30" height="30" viewBox="0 0 512 512"><path fill="#32BEA6" d="M504.1,256C504.1,119,393,7.9,256,7.9C119,7.9,7.9,119,7.9,256C7.9,393,119,504.1,256,504.1C393,504.1,504.1,393,504.1,256z"></path><path fill="#FFF" d="M392.6,172.9c-5.8-15.1-17.7-12.7-30.6-10.1c-7.7,1.6-42,11.6-96.1,68.8c-22.5,23.7-37.3,42.6-47.1,57c-6-7.3-12.8-15.2-20-22.3C176.7,244.2,152,229,151,228.4c-10.3-6.3-23.8-3.1-30.2,7.3c-6.3,10.3-3.1,23.8,7.2,30.2c0.2,0.1,21.4,13.2,39.6,31.5c18.6,18.6,35.5,43.8,35.7,44.1c4.1,6.2,11,9.8,18.3,9.8c1.2,0,2.5-0.1,3.8-0.3c8.6-1.5,15.4-7.9,17.5-16.3c0.1-0.2,8.8-24.3,54.7-72.7c37-39.1,61.7-51.5,70.3-54.9c0.1,0,0.1,0,0.3,0c0,0,0.3-0.1,0.8-0.4c1.5-0.6,2.3-0.8,2.3-0.8c-0.4,0.1-0.6,0.1-0.6,0.1l0-0.1c4-1.7,11.4-4.9,11.5-5C393.3,196.1,397,184.1,392.6,172.9z"></path></svg></td><td><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="30" height="30" viewBox="0 0 512 512"><path fill="#32BEA6" d="M504.1,256C504.1,119,393,7.9,256,7.9C119,7.9,7.9,119,7.9,256C7.9,393,119,504.1,256,504.1C393,504.1,504.1,393,504.1,256z"></path><path fill="#FFF" d="M392.6,172.9c-5.8-15.1-17.7-12.7-30.6-10.1c-7.7,1.6-42,11.6-96.1,68.8c-22.5,23.7-37.3,42.6-47.1,57c-6-7.3-12.8-15.2-20-22.3C176.7,244.2,152,229,151,228.4c-10.3-6.3-23.8-3.1-30.2,7.3c-6.3,10.3-3.1,23.8,7.2,30.2c0.2,0.1,21.4,13.2,39.6,31.5c18.6,18.6,35.5,43.8,35.7,44.1c4.1,6.2,11,9.8,18.3,9.8c1.2,0,2.5-0.1,3.8-0.3c8.6-1.5,15.4-7.9,17.5-16.3c0.1-0.2,8.8-24.3,54.7-72.7c37-39.1,61.7-51.5,70.3-54.9c0.1,0,0.1,0,0.3,0c0,0,0.3-0.1,0.8-0.4c1.5-0.6,2.3-0.8,2.3-0.8c-0.4,0.1-0.6,0.1-0.6,0.1l0-0.1c4-1.7,11.4-4.9,11.5-5C393.3,196.1,397,184.1,392.6,172.9z"></path></svg></td><td><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="30" height="30" viewBox="0 0 512 512"><path fill="#32BEA6" d="M504.1,256C504.1,119,393,7.9,256,7.9C119,7.9,7.9,119,7.9,256C7.9,393,119,504.1,256,504.1C393,504.1,504.1,393,504.1,256z"></path><path fill="#FFF" d="M392.6,172.9c-5.8-15.1-17.7-12.7-30.6-10.1c-7.7,1.6-42,11.6-96.1,68.8c-22.5,23.7-37.3,42.6-47.1,57c-6-7.3-12.8-15.2-20-22.3C176.7,244.2,152,229,151,228.4c-10.3-6.3-23.8-3.1-30.2,7.3c-6.3,10.3-3.1,23.8,7.2,30.2c0.2,0.1,21.4,13.2,39.6,31.5c18.6,18.6,35.5,43.8,35.7,44.1c4.1,6.2,11,9.8,18.3,9.8c1.2,0,2.5-0.1,3.8-0.3c8.6-1.5,15.4-7.9,17.5-16.3c0.1-0.2,8.8-24.3,54.7-72.7c37-39.1,61.7-51.5,70.3-54.9c0.1,0,0.1,0,0.3,0c0,0,0.3-0.1,0.8-0.4c1.5-0.6,2.3-0.8,2.3-0.8c-0.4,0.1-0.6,0.1-0.6,0.1l0-0.1c4-1.7,11.4-4.9,11.5-5C393.3,196.1,397,184.1,392.6,172.9z"></path></svg></td></tr><tr><td>protected</td><td><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="30" height="30" viewBox="0 0 512 512"><path fill="#32BEA6" d="M504.1,256C504.1,119,393,7.9,256,7.9C119,7.9,7.9,119,7.9,256C7.9,393,119,504.1,256,504.1C393,504.1,504.1,393,504.1,256z"></path><path fill="#FFF" d="M392.6,172.9c-5.8-15.1-17.7-12.7-30.6-10.1c-7.7,1.6-42,11.6-96.1,68.8c-22.5,23.7-37.3,42.6-47.1,57c-6-7.3-12.8-15.2-20-22.3C176.7,244.2,152,229,151,228.4c-10.3-6.3-23.8-3.1-30.2,7.3c-6.3,10.3-3.1,23.8,7.2,30.2c0.2,0.1,21.4,13.2,39.6,31.5c18.6,18.6,35.5,43.8,35.7,44.1c4.1,6.2,11,9.8,18.3,9.8c1.2,0,2.5-0.1,3.8-0.3c8.6-1.5,15.4-7.9,17.5-16.3c0.1-0.2,8.8-24.3,54.7-72.7c37-39.1,61.7-51.5,70.3-54.9c0.1,0,0.1,0,0.3,0c0,0,0.3-0.1,0.8-0.4c1.5-0.6,2.3-0.8,2.3-0.8c-0.4,0.1-0.6,0.1-0.6,0.1l0-0.1c4-1.7,11.4-4.9,11.5-5C393.3,196.1,397,184.1,392.6,172.9z"></path></svg></td><td><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="30" height="30" viewBox="0 0 512 512"><path fill="#32BEA6" d="M504.1,256C504.1,119,393,7.9,256,7.9C119,7.9,7.9,119,7.9,256C7.9,393,119,504.1,256,504.1C393,504.1,504.1,393,504.1,256z"></path><path fill="#FFF" d="M392.6,172.9c-5.8-15.1-17.7-12.7-30.6-10.1c-7.7,1.6-42,11.6-96.1,68.8c-22.5,23.7-37.3,42.6-47.1,57c-6-7.3-12.8-15.2-20-22.3C176.7,244.2,152,229,151,228.4c-10.3-6.3-23.8-3.1-30.2,7.3c-6.3,10.3-3.1,23.8,7.2,30.2c0.2,0.1,21.4,13.2,39.6,31.5c18.6,18.6,35.5,43.8,35.7,44.1c4.1,6.2,11,9.8,18.3,9.8c1.2,0,2.5-0.1,3.8-0.3c8.6-1.5,15.4-7.9,17.5-16.3c0.1-0.2,8.8-24.3,54.7-72.7c37-39.1,61.7-51.5,70.3-54.9c0.1,0,0.1,0,0.3,0c0,0,0.3-0.1,0.8-0.4c1.5-0.6,2.3-0.8,2.3-0.8c-0.4,0.1-0.6,0.1-0.6,0.1l0-0.1c4-1.7,11.4-4.9,11.5-5C393.3,196.1,397,184.1,392.6,172.9z"></path></svg></td><td><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="35" height="35" viewBox="0 0 48 48"><path fill="#f44336" d="M44,24c0,11.045-8.955,20-20,20S4,35.045,4,24S12.955,4,24,4S44,12.955,44,24z"></path><path fill="#fff" d="M29.656,15.516l2.828,2.828l-14.14,14.14l-2.828-2.828L29.656,15.516z"></path><path fill="#fff" d="M32.484,29.656l-2.828,2.828l-14.14-14.14l2.828-2.828L32.484,29.656z"></path></svg></td></tr><tr><td>private</td><td><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="30" height="30" viewBox="0 0 512 512"><path fill="#32BEA6" d="M504.1,256C504.1,119,393,7.9,256,7.9C119,7.9,7.9,119,7.9,256C7.9,393,119,504.1,256,504.1C393,504.1,504.1,393,504.1,256z"></path><path fill="#FFF" d="M392.6,172.9c-5.8-15.1-17.7-12.7-30.6-10.1c-7.7,1.6-42,11.6-96.1,68.8c-22.5,23.7-37.3,42.6-47.1,57c-6-7.3-12.8-15.2-20-22.3C176.7,244.2,152,229,151,228.4c-10.3-6.3-23.8-3.1-30.2,7.3c-6.3,10.3-3.1,23.8,7.2,30.2c0.2,0.1,21.4,13.2,39.6,31.5c18.6,18.6,35.5,43.8,35.7,44.1c4.1,6.2,11,9.8,18.3,9.8c1.2,0,2.5-0.1,3.8-0.3c8.6-1.5,15.4-7.9,17.5-16.3c0.1-0.2,8.8-24.3,54.7-72.7c37-39.1,61.7-51.5,70.3-54.9c0.1,0,0.1,0,0.3,0c0,0,0.3-0.1,0.8-0.4c1.5-0.6,2.3-0.8,2.3-0.8c-0.4,0.1-0.6,0.1-0.6,0.1l0-0.1c4-1.7,11.4-4.9,11.5-5C393.3,196.1,397,184.1,392.6,172.9z"></path></svg></td><td><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="35" height="35" viewBox="0 0 48 48"><path fill="#f44336" d="M44,24c0,11.045-8.955,20-20,20S4,35.045,4,24S12.955,4,24,4S44,12.955,44,24z"></path><path fill="#fff" d="M29.656,15.516l2.828,2.828l-14.14,14.14l-2.828-2.828L29.656,15.516z"></path><path fill="#fff" d="M32.484,29.656l-2.828,2.828l-14.14-14.14l2.828-2.828L32.484,29.656z"></path></svg></td><td><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="35" height="35" viewBox="0 0 48 48"><path fill="#f44336" d="M44,24c0,11.045-8.955,20-20,20S4,35.045,4,24S12.955,4,24,4S44,12.955,44,24z"></path><path fill="#fff" d="M29.656,15.516l2.828,2.828l-14.14,14.14l-2.828-2.828L29.656,15.516z"></path><path fill="#fff" d="M32.484,29.656l-2.828,2.828l-14.14-14.14l2.828-2.828L32.484,29.656z"></path></svg></td></tr></tbody></table><div class="modifiers__block"><h3 class="mo_heading">Static</h3><p class="modifiers__text">Статические члены принадлежат самому классу, а&nbsp;не&nbsp;экземплярам этого класса и&nbsp;соответственно используются самим классом.</p><p class="modifiers__text"><b>Наследование:</b> Статические свойства и&nbsp;методы могут быть унаследованы, но&nbsp;они не&nbsp;копируются в&nbsp;экземпляры подклассов.</p><p class="modifiers__text"><b>Не&nbsp;привязаны к&nbsp;экземплярам:</b> Статические члены не&nbsp;могут использовать `this` для доступа к&nbsp;экземплярным свойствам и&nbsp;методам, так как `this` в&nbsp;статических контекстах ссылается на&nbsp;сам класс, а&nbsp;не&nbsp;на&nbsp;экземпляр.</p><pre class="pre">class Car {
  model: string;
  color: string;
  static wheels: number;

  constructor(model: string, color: string) {
    this.model = model;
    this.color = color;
    Car.wheels = 4;
  }

  static greet() {
    console.log(`My car has ${Car.wheels} wheels.`);
  }
}

console.log(Car.wheels); <i>// 4</i>
console.log(Car.greet); <i>// My car has 4 wheels.</i></pre></div></div></section><section class="interface section-scroll" id="interface"><div class="interface__container"><h2 class="interface__title">Интерфейс в TS</h2><p class="interface__text"><b>Интерфейс</b> можно назвать контрактом, который определяет методы и&nbsp;свойства объекта, которые объект обязуется реализовать.</p><pre class="pre"><i>// интерфейс</i>
interface ICar {
  model: string;
  color: string;
  move?(distance: number): number; <i>// необязательное свойство</i>
  readonly wheels: number; <i>// readonly - только для чтения</i>
}

const myCar: ICar = {
  model: "Kalina",
  color: "black",
  speed: 160 <i>// Ошибка: свойство 'speed' недоступно, т.к. его нет в интерфейсе</i>
  wheels: 4 <i>// Ошибка: свойство только для чтения</i>
};</pre><br><p class="inteface__text">Расширение интерфейса:</p><pre class="pre"><i>// интерфейс</i>
interface ICar {
  model: string;
  color: string;
  move?(distance: number): number; <i>// необязательное свойство</i>
}

<i>// расширение интерфейса</i>
interface ICar {
  speed: number;
}

<i>// выдаст ошибку, т.к. нет свойства speed</i>
const myCar: ICar = {
  model: "Kalina",
  color: "black"
};
br</pre><p class="interface__text">Наследование интерфейса:</p><pre class="pre"><i>// интерфейс</i>
interface ICar {
  model: string;
  color: string;
  move?(distance: number): number; <i>// необязательное свойство</i>
}

<i>// наследование интерфейса</i>
interface IKALINA extends ICar {
  speed: number;
}

const myCar: IKALINA = {
  model: "Kalina",
  color: "black"
  speed: 160 <i>// Если указать интерфейс ICar, то выдаст ошибку, потому что свойство speed недоступно</i>
};</pre><br><p class="interface__text">Реализация клас</p><pre class="pre"><i>// интерфейс</i>
interface ICar {
  model: string;
  color: string;
  move?(distance: number): number; <i>// необязательное свойство</i>
}

<i>// реализация классом (класс имплементирует интерфейс)</i>
class Kalina implements ICar {
  model: string;
  color: string;
  moveDirection: string; <i>// в классе создаётся новое свойство, тем самым расширяя родительский класс</i>

  constructor(color: string, moveDirection: string) {
    this.model = "Kalina";
    this.color = color;
    this.moveDirection = moveDirection;
  }

  changeDirection(moveDirection: string) {
    this.moveDirection = moveDirection;
  }
}

<i>// реализация классом (класс имплементирует интерфейс)</i>
class Priora implements ICar {
  model: string;
  color: string;
  moveDirection: string; <i>// в классе создаётся новое свойство, тем самым расширяя родительский класс</i>

  constructor(color: string, moveDirection: string) {
    this.model = "Priora";
    this.color = color;
    this.moveDirection = moveDirection;
  }

  changeDirection(moveDirection: string) {
    this.moveDirection = moveDirection;
  }
}</pre><br><p class="interface__text">Инплементация интерфейса родительским клас</p><pre class="pre"><i>// интерфейс</i>
interface ICar {
  model: string;
  color: string;
  move?(distance: number): number; <i>// необязательное свойство</i>
}

<i>// родительский класс</i>
<i>// abstract class Car implements ICar {} - доступно только наследование. Экземпляры создать нельзя. </i>
class Car implements ICar {
  model: string;
  color: string;
  moveDirection: string; <i>// в классе создаётся новое свойство, тем самым расширяя родительский класс</i>

  constructor(model: string, color: string, moveDirection: string) {
    super(model, color, moveDirection);
  }

  changeDirection(moveDirection: string) {
    this.moveDirection = moveDirection;
  }
}

<i>// возможно создать экземпляр родительского класса</i>
const anyCar = new Car("BMW", "black", "top");

<i>// наследование родительского класса</i>
class Kalina extends Car implements ICar {}
class Priora extends Car implements ICar {}

const kalina = new Kalina("Kalina", "black", "top");
const priora = new Priora("Priora", "black", "top");</pre></div></section><section class="union section-scroll" id="union"><div class="union__container"><h2 class="union__title">Объединение и пересечение псевдонимов</h2><p class="union__text"><b>Объединение (Union)</b>&nbsp;&mdash; это тип, который может принимать значения нескольких различных типов, но выводить один. В&nbsp;TypeScript объединение определяется с&nbsp;помощью символа `|`.</p><p class="union__text"><b>Пересечение (Intersection)</b>&nbsp;&mdash; это тип, который одновременно представляет все типы, которые он&nbsp;объединяет. Пересечение определяется с&nbsp;помощью символа `&amp;`.</p><pre class="pre">type IdName = {
  id: number;
  name: string;
}

type Age = {
  age: number;
}


<i>// объединение</i>
type User1 = IdName | Age;

const user1: User1 = {
  id: 1,
  name: "John"
}


<i>// пересечение</i>
type User2 = IdName &amp; Age;

const user2: User2 = {
  id: 1,
  name: "John",
  age: 30
}</pre><pre class="pre">type TypeA = { a: number };
type TypeB = { b: string };

<i>// Объединение</i>
type UnionType = string | number;
let value: UnionType;

value = "Hello"; <i>// OK</i>
value = 42; <i>// OK</i>
value = true; <i>// Error: Type 'boolean' is not assignable to type 'UnionType'</i>


<i>// Пересечение</i>
type IntersectionType = TypeA &amp;&nbsp;TypeB;
const intersetcionValue: IntersectionType = { a: 1, b: 'hello' }; <i>// OK</i>

<i>// Пример с непересекаемыми типами</i>
type NeverType = string &amp;&nbsp;number;
let nevrValue: NeverType; <i>// Type: never</i></pre><br><p class="union__text">Оператор <a href="#readonly">readonly</a> делает свойства объектов, массивов или других структур данных доступными только для чтения (immutable</p><pre class="pre"><i>// readonly</i>
const obj = { a: 1 };
obj.a = 2; <i>// OK, свойство 'a' можно изменить:</i>
type ReadonlyType = {
  readonly a: number;
};

let readonlyObj: ReadonlyType = { a: 1 };
readonlyObj.a = 2; <i>// Error: Cannot assign to 'a' because it is a read-only property</i>


type ReadonlyObject = {
  readonly x: number;
  readonly y: number;
}

let point: ReadonlyObject = { x: 10, y: 20 };
point.x = 15; <i>// Error</i>

let readonlyArray: readonly number[] = [1, 2, 3];
readonlyArray[0] = 4; <i>// Error</i></pre><br><h3 class="union__title">Заимствование типов свойств у других объектов, интерфейсов:</h3><a href="#borrowing">Аналогичные варианты заимстования</a><pre class="pre"><i>// Взятие типа свойства у интерфейса</i>
interface User {
  name: string;
  age: number;
}

// type UserNameType = User.name; <i>// Error</i>
type UserNameType = User['name']; <i>// UserNameType: string</i>
type UserAgeType = User['age']; <i>// UserAgeType: number</i></pre><pre class="pre"><i>// Взятие типа свойства у объекта</i>
const user = {
  name: "Elin",
  age: 30,
};

type UserType = typeof user;
type UserNameType = UserType['name']; <i>// UserNameType: string</i>
type UserAgeType = UserType['age']; <i>// UserAgeType: number</i></pre><p class="union__text"><a href="#utilitarian">Утилитарные типы в пересечениях</a></p></div></section><section class="tuple section-scroll" id="tuple"><div class="tuple__container"><h2 class="tuple__heading">Динамические объекты и кортежи</h2><h3 class="tuple__heading">Динамические объекты</h3><p class="tuple__text">В <strong>TypeScript</strong> "динамический объект" - это объект, свойства которого заранее не известны.</p><pre class="pre"><i>// [index: type]</i>
type Value = string | number | boolean;            

<i>// value: использует один из трёх типов</i>
type DynamicObject = {
  [key: string]: Value;
};

<i>// Такой объект может содержать любое количество свойств с&nbsp;ключами-строками и&nbsp;значениями-строками.</i>
const settings: DynamicObject = {
  theme: 'dark',
  language: 'en',
  timezone: 'UTC',
};</pre><hr><h3 class="tuple__heading" id="tuples">Кортежи</h3><p class="tuple__text"><b>Кортежи</b>&nbsp;&mdash; это массивы с&nbsp;фиксированной длиной и&nbsp;типами на&nbsp;каждой позиции.</p><p class="tuple__text">Идеально подходят, когда структура известна заранее.</p><p class="tuple__text">Это полезно, когда надо описать структуру данных с жёстко определённым количеством элементов и типов данных.</p><p class="tuple__text">Т.е., кортежи в&nbsp;отличии от&nbsp;массивов всегда имеют одинаковое количество элементов, а&nbsp;у&nbsp;каждого элемента указывается свой определённый тип.</p><pre class="pre">type User = [number, string]; <i>// или type User = [id: number, name: string];</i>

const user: User = [1, "John"];

<i>/* ========================================================================================================================= */</i>
<i>// Описание массива</i>
const number: number[] = [1, 2, 3, 4];

<i>// Описание кортежа</i>
const user: [string, number] = ['Elin', 8];

const testFunc = (arr: [string, number]): [string, number] =&gt; {
  return arr;
}

const [userName, age] = testFunc(user);

console.log([userName, age]); <i>// ['Elin', 8]</i></pre><hr><p class="tuple__text">Для строгой типизации также хорошо подходит специальный тип <a href="#record" class="tuple__link">Record</a>.</p><hr><h3 class="tuple__heading">Автоматическое определение типов на основе значений</h3><pre class="pre"><i>// Пример с массивом</i>
const x = [1, 2, 3]; <i>// Тип x: number[]</i>

const y = [1, 2, 3] as const; <i>// Тип y: <a href="#readonly">readonly</a> [1, 2, 3]</i>

<i>// Пример с объектом</i>
const obj = { a: 1, b: 2 } as const; <i>// Тип obj: { <a href="#readonly">readonly</a> a: 1, <a href="#readonly">readonly</a> b: 2 }</i></pre><p class="tuple__text"><code>as const</code> - заставляет компилятор воспринимать значения как неизменяемые и конкретные.</p><pre class="pre"><i>// Пример:</i>
const color = "green"; <i>// может быть любая строка, например "blue"</i>

const color = "green" as const; <i>// будет только "green"</i>

<i>/* ============================================================================= */</i>
<i>// Пример с массивом:</i>
const directions = ['up', 'down']; <i>// [string, string] - любые строки в массиве</i>

const directions = ['up', 'down'] as const; <i>// ['up', 'down'] - только данные значения</i></pre></div></section><section class="generics section-scroll" id="generics"><div class="generics__container"><h2 class="generics__title">Дженерики</h2><p class="generics__text">В&nbsp;<strong>TypeScript</strong> *дженерики* (generics)&nbsp;&mdash; это способ писать обобщённый, универсальный код, который может работать с&nbsp;разными типами, сохраняя при этом *строгую типизацию*.</p><p class="generics__text"><b>Они позволяют:</b></p><ul class="generics__list generics-list"><li class="generics-list__item"><span class="generics-list__item-text">Писать переиспользуемые функции и&nbsp;классы.</span></li><li class="generics-list__item"><span class="generics-list__item-text">Сохранять информацию о&nbsp;типе без использования `any`.</span></li><li class="generics-list__item"><span class="generics-list__item-text">Улучшать читаемость и&nbsp;безопасность кода.</span></li></ul><p class="generics__text"><b>Простой пример с дженериками:</b></p><pre class="pre">function identity&lt;T&gt;(value: T): T {
  return value;
}

const result = identity&lt;number&gt;(123); <i>// result: number</i></pre><p class="generics__text"><code>&lt;T&gt;</code> - это параметр типа.</p><p class="generics__text"><b>T</b> - будет "подставлен" <strong>TypeScript</strong>`ом при вызове.</p><code>const result = identity("Hello"); <i>// T = string, результат: string</i></code><br><br><pre class="pre"><i>/* #1 */</i>
<i>// #1.1</i>
<i>// type NumsAndString1 = (number | string)[]; первый вариант</i>
type NumsAndString2 = Array&lt;number | string&gt;; <i>// второй вариант</i>

const nums: NumsAndString2 = [1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(nums instanceof Array);
nums.push('puch');

<i>// #1.2</i>
type ArrayOf&lt;T&gt; = T[];
function createArrayOf&lt;T&gt;(...elements: T[]): ArrayOf&lt;T&gt; {
  return elements;
}
const arrayOfStrings: ArrayOf&lt;string&gt; = createArrayOf('строка 1', 'строка 2', 'строка 3')
const arrayOfNumbers: ArrayOf&lt;number&gt; = createArrayOf(9, 8, 7, 6, 5, 4, 3, 2, 1)</pre><br><pre class="pre"><i>/* #2 */</i>
<i>// функция</i>
function identity&lt;T&gt;(arg: T): T {
  console.log(arg);
  return arg;
}

const str = identity&lt;string&gt;('Hello');
const num = identity&lt;number&gt;(1);

<i>// &lt;T&gt; - объявление обощения(generic type parameter). Это обязательное объявление параметра типа.</i>

<i>// arg: T - применение обобщения к параметру. arg должен быть именно типа T, которыйй объявили ранее.</i>

<i>// ():T - применение обобщения к возвращаемому значение. Функция возвращает значение того же типа T, что и параметр arg.</i></pre><br><pre class="pre"><i>/* #3 */</i>
<i>// интерфейс</i>
interface Pair&lt;T, U&gt; {
  first: T;
  second: U;
}

const firstPair: Pair&lt;string, number&gt; = { first: 'One', second: 1 };
const secondPair: Pair&lt;string, boolean&gt; = { first: "Two", second: true };</pre><br><pre class="pre"><i>/* #4 */</i>
<i>// класс</i>
class Box&lt;T&gt; {
  private value: T;

  constructor(value: T) {
    this.value = value;
  }

  getValue(): T {
    return this.value;
  }
}

const box = new Box&lt;number&gt;(123);
console.log(box.getValue()); <i>// 123</i></pre><br><pre class="pre"><i>/* #5 */</i>
<i>// параметры с ограничениями</i>
interface Lengthwise {
  length: number;
}

<i>// функция выводит объект, массив или строку у которых есть свойство length и далее выводит длину массива, объекта или строки</i>
function logLength&lt;T extends Lengthwise&gt;(arg: T): void {
  console.log(arg.length);
}

logLength("Hello, World!"); <i>// выведет 13 - длина строки</i>
logLength([1, 2, 3]); <i>// выведет 3 - длина массива</i>
logLength(42); <i>// выведет ошибку, т.к., у числа нет свойства length</i></pre><br><h3 class="generics__heading">Дженерики в массивах</h3><pre class="pre"><i>// 1 определение типа MergeFn</i>
type MergeFn = &lt;T1, T2&gt;(arg1: T1[], arg2: T2[]) =&gt; (T1 | T2)[]

<i>// 2 определение функции</i>
function mergeArrays1&lt;T1, T2&gt;(ar1: T1[], ar2: T2[]): (T1 | T2)[] {
  return [...ar1, ...ar2];
}

<i>// 3 объявление функции</i>
const merg: MergeFn = mergeArrays1;

const numbers = [1, 2, 3];
const strings = ['a', 'b', 'c'];

const mergedArray = merg(numbers, strings);
console.log(mergedArray); <i>// Вывод: [1, 2, 3, 'a', 'b', 'c']</i>

<i>
/* при вызове функции компилятор TypeScript автоматически выводит типы `T1` и `T2` на основе переданных аргументов. */
</i></pre><br><h3 class="generics__heading">Дженерики в асинхронных функциях</h3><p class="generics__text">Вариант №1</p><pre class="pre"><i>// 1 определение интерфейса</i>
interface User {
  id: number;
  name: string;
  email: string;
}

<i>// 2 определение функции</i>
async function fetchData&lt;T&gt;(url: string): Promise&lt;T&gt; {
  const resp = await fetch(url);
  if (!resp.ok) {
    throw new Error(`Ошибка HTTP: ${resp.status}`);
  }
  return await resp.json() as T ; <i>// as T - TypeScript, поверь мне resp.json() имеет тип T</i>
}

<i>// 3 использование функции fetchData</i>
async function getUsers() {
  try {
    const users = await fetchData&lt;User[]&gt;('https://jsonplaceholder.typicode.com/users');
    console.log(users);

    // Дополнительная обработка данных пользователей
    users.forEach(user =&gt; {
      console.log(`ID: ${user.id}, Name: ${user.name}, Email: ${user.email}`);
    });
  } catch (error) {
    console.error('Ошибка при получении данных:', error);
  }
}

<i>// 4 вызов функции</i>
getUsers();</pre><br><p class="generics__text">Вариант №2</p><pre class="pre"><i>// 1 интерфейс Res&lt;T&gt;</i>
interface Res&lt;T&gt; {
  status: number;
  data: T;
}

<i>// 2 функция fetchData - вернёт всё, что угодно, в зависимости от того, что передали вместо unknown в Res&lt;unknown&gt;</i>
async function fetchData&lt;T extends Res&lt;unknown&gt;&gt;(url: string): Promise&lt;T&gt; {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  const responseData: T['data'] = await response.json();
  return { status: response.status, data: responseData } as T;
}
<i>
/*
fetchData - это асинхронная функция, принимающая URL в качестве аргумента и возвращающая Promise&lt;T&gt;.
Значение T должен соответствовать интерфейсу Res&lt;unknown&gt;, т.е., должна соответствовать структуре,
описанной в Res&lt;T&gt;, но также расширяет его. 

&lt;unknown&gt; - у data есть тип, но мы заранее не знаем какой он.

Внутри функции происходит:
- выполнение HTTP-запроса с помощью fetch
- провера на наличие ошибок в ответе. Если запрос не успешен (например, статус 404 или 500), выбрасывается ошибка
- получение данных из ответта в формате JSON и их типизация с использованием T['data']
- создание объекта, содержащего статус и данные, и возврат его как результат
*/
</i>

<i>// 3 интерфейс PostData</i>
interface PostData {
  id: number;
  userId: number;
  body: string;
  title: string;
}

<i>// 4 функция fetchPostData</i>
async function fetchPostData(url: string) {
  try {
    const response: Res&lt;PostData&gt; = await fetchData&lt;Res&lt;PostData&gt;&gt;(url);
    console.log("Статус ответа: ", response.status);
    console.log("Данные поста: ", response.data);
  } catch {
    console.error('Ошибка при получении данных:', error);
  }
}

<i>// Res&lt;PostData&gt; - интерфейс Res&lt;T&gt; получает структуру PostData для data.

/*
- Это асинхронная функция, которая пытается получить данные о посте с указанного URL (из `https://jsonplaceholder.typicode.com/posts/1`).
- Она использует `fetchData`, указывая обобщенный тип `Res&lt;PostData&gt;` для получения данных о посте.
- В блоке `try`:
  - Модель данных поста загружается и статус ответа и сами данные выводятся в консоль.
- В блоке `catch`:
  - Ловится возникшая ошибка, если что-то пошло не так при выполнении запроса, и выводит сообщение об ошибке.
*/
</i>

<i>// 5 вызов функции</i>
fetchPostData('https://jsonplaceholder.typicode.com/posts/1');</pre><br><p class="generics__text">Вариант №3</p><pre class="pre"><i>// 1 определение интерфейса TResponse</i>
type TResponse = {
  status: number;
  data: unknown;
}

<i>// 2 функция superFetch</i>
async function superFetch&lt;T extends TResponse&gt;(): Promise&lt;T&gt; {
  const t: T = await fetch('https://jsonplaceholder.typicode.com/posts/1').then(res =&gt; res.json());

  if (t.status &gt; 200) {
    return t;
  }
  throw new Error(`Ошибка HTTP: ${t.status}`);
}

<i>
/*
Эта асинхронная функция делает HTTP-запрос к указанному URL.
- Функция принимает параметр типа `T`, который должен наследоваться от `TResponse`.
- Данные из ответа преобразуются из JSON в объект `t`, который имеет тип `T`.
- Если статус ответа больше 200, функция возвращает объект `t`.
- В противном случае выбрасывается ошибка с сообщением, содержащим статус.
*/
</i>

<i>// 3 вызов функции</i>
const data = superFetch&lt;{
  status: 200 | 400;
  data: number;
}&gt;();

<i>// 4 интерфейс Resp</i>
interface Resp&lt;T&gt; {
  status: number;
  data: T; <i>// указывается конкретный тип данных в отличии от TResponse</i>
}

<i>// 5 функция fetchData</i>
async function fetchData&lt;TResp extends Resp&lt;unknown&gt; = Resp&lt;unknown&gt;&gt;(url: string): Promise&lt;TResp&gt; {
<i>// TResp обязательно должеть быть подтипом (extends) Resp&lt;unknown&gt;
  // = Resp&lt;unknown&gt; (знак =) — Устанавливается значение по умолчанию для дженерика, т.е., если не указать тип явно, то будет Resp&lt;unknown&gt;.
  // const data = await fetchData('/api/user'); - без указания типа (data: Resp&lt;unknown&gt;).
  // const userData = await fetchData&lt;Resp&lt;User&gt;&gt;('/api/user/1'); - явное указание типа.
</i>
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Ошибка HTTP: ${response.status}`);
  }
  const responseData: TResp["data"] = await response.json();
  return { status: response.status, data: responseData } as TResp;
}

<i>// 6 функция fetchUserData</i>
async function fetchUserData() {
  try {
    const response = await fetchData('https://api.example.com/users/1');
    console.log('Статус ответа: ', response.status);
    console.log('Данные пользователя: ', response.data);
  } catch (error) {
    console.error('Ошибка при получении данных:', error);
  }
}

<i>// 7 вызов функций</i>
fetchUserData();
const result1 = fetchData('https:/example.com/data');
const result2 = fetchData&lt;number&gt;('https:/example.com/data');</pre><br><h3 class="generic__heading">Дженерики в классах</h3><pre class="pre"><i>// 1 определение интерфейса</i>
interface IStack&lt;T&gt; {
  push(item: T): void;
  pop(): T | undefined;
  peek(): T | undefined;
  isEmpty(): boolean;
  size(): number;
  clear(): void;
}

<i>// 2 определение класса</i>
class Stack&lt;T&gt; implements IStack&lt;T&gt; {
  private items: T[];
  constructor() {
    this.items = [];
  }

  <i>// 2.1. push - добавляет элемент в стек</i>
  push(item: T): void {
    this.items.push(item);
  }

  <i>// 2.2. pop - удаляет и возращает последний добавленный элемент стека. Если стек пустой, возвращает undefined</i>
  pop(): T | undefined {
    return this.items.pop();
  }

  <i>// 2.3. peek - возвращает последний добавленный элемент стека. Если стек пустой, возвращает undefined</i>
  peek(): T | undefined {
    return this.items[this.items.length - 1];
  }

  <i>// 2.4. isEmpty - возвращает true, если стек пустой, и false в противном случае</i>
  isEmpty(): boolean {
    return this.items.length === 0;
  }

  <i>// 2.5. size - возвращает количество элементов в стеке</i>
  size(): number {
    return this.items.length;
  }

  <i>// 2.6. clear - очищает стек, устанавливая items в пустой массив</i>
  clear(): void {
    this.items = [];
  }
}

<i>/* ПРИМЕР */</i>
<i>// создание экземпляра класса, который соответствует интерфейсу.</i>
<i>// Это означает, что переменная stack может использоваться как интерфейс,</i>
<i>// а не как конкретный класс, что позволяет использовать любые реализации интерфейса.</i>
const stack: IStack&lt;number&gt; = new Stack&lt;number&gt;();

<i>// добавление элемента в массив</i>
stack.push(1);
stack.push(2); 
stack.push(3);

<i>// информация о стеке</i>
console.log("Размер стека:", stack.size()); <i>// 3</i>
console.log("Вершина стека:", stack.peek()); <i>// 3</i>

<i>// извлечение элеметнов из стека</i>
while (!stack.isEmpty()) {
  console.log("Извлечённый элемент: "stack.pop());
}</pre><br><pre class="pre"><i>// 1 определение класса Board</i>
class Board&lt;T, U&gt; {
  private first: T;
  private second: U;

  constructor(first: T, second: U) {
    this.first = first;
    this.second = second;
  }

  <i>// swap - возвращает новый объект класса Board, в котором типы T и U были заменены местами.</i>
  swap(): Board&lt;U, T&gt; {
    return new Board(this.second, this.first);
  }

  <i>// print - выводит значения свойств first и second в консоль.</i>
  print(): void {
    console.log(`First: ${this.first}, Second: ${this.second}`);
  }
}

<i>/* ПРИМЕР БЕЗ ИЗМЕНЕНИЙ */</i>
const pair = new Board&lt;string, string&gt;("white", "red");
pair.print(); <i>// First: white, Second: red</i>

<i>/* ПРИМЕР С ИЗМЕНЕНИЕМ ТИПОВ */</i>
const swappedPair = pair.swap();
swappedPair.print(); <i>// First: red, Second: white</i>

<i>/* ПРИМЕР С РАЗНЫМИ ТИПАМИ */</i>
const differentPair = new Board&lt;number, boolean&gt;(10, false);
pair.print(); <i>// First: 10, Second: false</i>

<i>/* ПРИМЕР С РАЗНЫМИ ТИПАМИ И ИЗМЕНЕНИЕМ ТИПОВ */</i>
const swappedDifferentPair = differentPair.swap();
swappedDifferentPair.print(); <i>// First: false, Second: 10</i></pre><a class="generics__download" id="download-link" href="../files-download/code.docx" download="../files-download/code.docx">Скачать файл с кодом</a></div></section><section class="optional section-scroll" id="optional"><div class="optional__container"><h2 class="optional__title">Функции: опциональные параметры и перегрузка</h2><pre class="pre"><i>// Опциональные параметры</i>
function greet(name?: string): string {
  return `Hello, ${name || "Guest"}!`;
}

console.log(greet()); <i>// Hello, Guest!</i>
console.log(greet("Elin")); <i>// Hello, Elin!</i>



<i>// Параметры по умолчанию</i>
function greetDefault(name: string = "Guest"): string {
  return `Hello, ${name}`;
}

console.log(greetDefault()); <i>// Hello, Guest!</i>
console.log(greetDefault("Elin")); <i>// Hello, Elin!</i></pre><br><pre class="pre"><i>// Перегрузка: вариант с обычными функциями</i>
function add(a: number, b: number): number;
function add(a: string, b: string): string;
function add(a: any, b: any): any {
  return a + b;
};

<i>// Сигнатура - это совокупность входных параметров функции и типа её возвращаемого значения.</i>
<i>// Иными словами это связь между типами входных параметров и типа возращаемого значения функции.</i>

console.log(add(1, 2)); <i>// 3</i>
console.log(add('Hello, ', 'World!')); <i>// Hello, World!</i></pre><p class="optional__text">В&nbsp;<strong>TypeScript</strong> допускается только одна реализация перегруженной функции. Остальные - только сигнатуры.</p><p class="optional__text">Реализация должна сама &laquo;распознать&raquo; с&nbsp;помощью `typeof` или проверок, какие аргументы были переданы и&nbsp;как действовать.</p><p class="optional__text">Пример:</p><pre class="pre">function add(a: string, b: string): string;
function add(a: number, b: number): number;
function add(a: any, b: any): any {
  if (typeof a === "string" && typeof b === "string") {
    return "string";
  } else if (typeof a === "number" && typeof b === "number") {
    return "number";
  } else {
    return "any";
  }
}</pre><br><pre class="pre"><i>// Перегрузка: вариант с классом</i>
class Calculator {
  add(a: number, b: number): number;
  add(a: string, b: string): string;
  add(a: any, b: any): any {
    return a + b;
  };

  testAdd(a: number | string, b: number | string): number | string {
    return a + b; <i>// TypeScript подчеркнёт как ошибку,</i>
    <i>// т.к., первым значением может быть число, а второе строка, что выведет ошибку.</i>
    <i>// Однако, если первым значением будет строка, а вторым число, то ошибки не будет.</i>
    <i>// Поэтому TypeScript заранее предупреждает, подчёркивая на стадии объявлении функции/метода.</i>
  }
}

const calc = new Calculator();
console.log(calc.add(1, 2)); <i>// 3</i>
console.log(calc.add('Hello, ', 'World!')); <i>// Hello, World!</i>
</pre></div></section><section class="operators section-scroll" id="operators"><div class="operators__container"><h2 class="operators__title">typeof, import type и keyof - извлечение типов из значений</h2><pre class="pre"><i>// typeof</i>
const num = 42;
type NumType = typeof num; <i>//NumType: number</i>

const str = "Hello";
type StrType = typeof str; <i>// StrType: string</i>

const obj = { x: 10, y: 20};
type ObjType = typeof obj; <i>// ObjType: { x: number; y: number; }</i>

const arr = [1, 2, 3];
type ArrType = typeof arr; <i>// ArrType: number[]</i></pre><pre class="pre"><i>// import type</i>
<i>// file: types.ts</i>
export type User = {
  name: string;
  age: number;
};

export const user: User = {
  name: "Elin",
  age: 8,
};

<i>/* ====================================================================== */</i>
<i>// file: main.ts</i>
import { user } from './types';
import type { User } from './types';

function greet(user: User): string {
  return `Hello, ${user.name}!`;
}</pre><pre class="pre"><i>// keyof</i>
<i>// Пример с объектом</i>
const person = {
  name: "Elin",
  age: 8,
};
type Person = typeof person; <i>// сначала надо извлечь тип с помощью typeof</i>
type PersonKeys = keyof Person; <i>// "name" | "age"</i>
<i>// type PersonKeys = keyof typeof Person;</i>
<i>// сокращённый вариант. Выведет "name" | "age"</i>

<i>// Пример с</i> <a href="#record" style="color: rgb(60, 245, 245)">Record</a>
type Roles = Record&lt;"admin" | "user" | "guest", string[]&gt;;
type RolesKeys = keyof Roles; <i>// "admin" | "user" | "guest"</i>

<i>// Пример с интерфейсом</i>
interface Car {
  make: string;
  model: string;
  year: number;
};
type CarKeys = keyof Car; <i>// "make" | "model" | "year"</i></pre></div></section></main><footer class="footer section-scroll" id="footer"><div class="footer__container"><h2 class="footer__title">FOOTER</h2></div></footer></div><script defer="defer" src="scripts.815658e97cd3da4130cb.js"></script></body>